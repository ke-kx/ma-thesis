\chapter{Detecting Missing Method Calls}\label{ch:dmmc}
\todo[inline]{
INTRO WHAT? - why is it interesting to detect them + what method are we using oÃ¤?
%--- quick intro again why it is interesting to detect them
thinking back to example in introduction, it is easy to see that there are bugs out there which occur because of missing method calls
additionally Monperrus et al. showed in their informal evaluation that real software systems have many bugs related to missing method calls
}

%--- overview of this chapter
In this chapter we will first give a proper explanation of the method proposed by Monperrus et al..
This includes a proper qualification of the notions of type usages as well as their equality and almost equality, which have already been mentioned in the previous chapter.
We will then explain how the strangeness score, which describes the amount a particular type usage is different from its relevant neighbors, is calculated, before going into detail how the potentially missing calls are determined.

In the second section of this chapter, we explain some minor tweaks to the type usage notion, whose ability to detect missing method calls we explore further in Chapter \ref{ch:eval}.
\todo{more details? -> when proper contents are decided}

\section{The Majority Rule}
%-> existing work
\todo{make sure that chapter intro + this section intro work well together}

The intuition behind the majority rule, is that a piece of code is likely to contain a defect, if there are none or very few equal instances, but a lot of slightly different instances.
It then seems likely that the code which appears only a selected few times should be adapted in a way to match the majority of slightly different instances.

An analogy which explains the idea well goes as follows.
Imagine being the waiter preparing the tables in a restaurant.
There are 100 seats and each of them is equipped with a plate, a knife on the right and a fork on the left.
However, only 99 of them have a spoon above the plate, there is one seat $s$ which is missing the spoon.
Then it is highly likely, that this one exception to the rule ``each seat should have a plate, a knife, a fork and a spoon'' is a mistake and you should add the spoon to the singular seat $s$ where it is missing.

The remainder of this section extends this idea to object oriented software and formalizes the different notions required to implement a system detection such places.
In this context each piece of cutlery (knife, spoon, fork) can be imagined as a method call, i.e. we extend the concept of the majority rule to type usages.

\subsection{Type Usages}

Generally speaking type usages are an abstraction over analyzed code.
They ignore the order of method calls and are only concerned which the list of method calls on an object of a particular type occurring in the body of some method.
The important information which is associated with a type usage is thus as follows: the type of the object, the list of methods invoked and the context.
The context is defined as the name of the method in which the type usage appears together with the type of its parameters.
%todo i think the return type is ignored?

\todo[inline]{EXMAPLE!!! + description}

%--- formalized -> read the papers again for inspiration
Formalized, a type usage consists of the following:
For each variable $x$, its type $T(x)$ and the context $C(x)$, which is the name of the method in which $x$ appears and the type of its parameters.
Additionally, the list of methods which are invoked on $x$ within $C(x)$: $M(x) =\{ m_1, m_2, \dotsc, m_n\}$.
If there are two variables of the same type, this results in two type usages being extracted (unless they refer to the same object, more on this in Section \ref{sec:bytecode}).

\todo[inline]{ again example: code + the corresponding values for T(x), C(x), M(x), maybe same figure as example above 
maybe use the example from intro (button)?!
}

\subsection{Exact and Almost Similarity}

%--- what are exactly equal and almost equal
To detect type usages which are anomalous by the majority rule, we now need a notion what it means for two type usages to be exactly similar and only almost similar.
\todo{some better explanation WHY we need this / add it in section intro?}
Informally, we say that two type usages are exactly similar, iff they have the same type, the type usage appears in a similar method (i.e. the context is identical) and if their list of method calls is identical.
We call these type usages ``similar'' instead of ``equal'', because several things are indeed not the same: Variable names, surrounding or interspersed code, method order and the location are all disregarded and might indeed be different.

As an example, \ldots
\todo[inline]{include examples + describe}

The notion of almost similarity is also not far away: We say that a type usage $y$ is almost similar to a given type usage $y$, if they share the same type and context and the list of method calls of $y$ is the same as the method calls of $x$ plus one additional call.
\todo[inline]{again include + describe example, probably in same figure?}

%--- formalized
To formalize these notions, we define two binary relationships over type usages.
The relationship for exact similarity is called $E$ and we say that two type usages $x$ and $y$ are exactly similar if and only if:
\begin{align*}
xEy \iff & T(x) = T(y) \: \land \\
         & C(x) = C(y) \: \land \\
         & M(x) = M(y)
\end{align*}
\todo{potentially change alignment to make look a bit nicer}

Given this, the set of exactly similar type usages in relation to $x$ is defined as:
\begin{equation*}
E(x) = \{y \mid xEy \}
\end{equation*}
Observe that this relation holds true for the identity, i.e. $xEx$ is always true and $x \in E(x)$ (and thus $|E(x)| \geq 1$

For almost similarity we define the relation $A$ which holds if two type usages are almost similar.
A type usage $y$ is almost similar to a type usage $x$ iff:
\begin{align*}
xAy \iff & T(x) = T(y) \: \land \\
         & C(x) = C(y) \: \land \\
         & M(x) \subset M(y) \: \land \\
         & |M(y)| = |M(x)| + 1
\end{align*}

Similarly to $E(x)$ we define $A(x)$ as the set of type usages which are almost similar to $x$:
\begin{equation*}
A(x) = \{y \mid xAy \}
\end{equation*}

In contrast to $E(x)$, $A(x)$ can be empty and $|A(x)|\geq0$.

It is possible to further refine the definition of almost similarity.
Instead of looking for type usages which have the same method calls plus one additional one, it is also possible to consider at those type usages which feature the same method calls plus $k$ additional ones.
Then, in the definition of $A$ the last line changes as follows: $|M(y)| = |M(x)| + k, k\geq1$
\todo{mention ignoring the context here?!}

Note that given a codebase with $n$ type usages the sets $E(x)$ and $A(x)$ can be computed in linear time $O(n)$ by iterating once through all type usages and checking for similarity or almost similarity.

\subsection{The Strangeness Score}

Recall the assumption behind the majority rule: A type usage is abnormal, if a small number of type usages is exactly similar, but a large number are almost similar.
Informally, this means a few places use this type in exactly the same way, but a big majority use it in a way which is slightly different (by exactly one method call).
Assuming the majority is correct, the type usage under scrutiny is deviant and potentially erroneous.

To capture concretely how anomalous an object is, we need a measure of strangeness.
This will be the strangeness score.
It allows to order type usages by how much of an outlier they are and thus to identify the ``strangest'' type usages, which are most interesting for evaluation by a human expert.

%--- strangeness score calculation
Formally, we define the S(trangeness)-Score as:
\begin{equation*}
    \operatorname{S-score}(x) = 1 - \frac{|E(x)|}{|E(x)|+|A(x)|}
\end{equation*}

To see that this definition makes sense, consider the following extreme cases:
Given one type usage $a$ without any additional exactly similar or almost similar type usages means $|E(a)| = 1$ and $|A(a)| = 0$.
Then, we calculate the strangeness score: $\operatorname{S-score}(a) = 1-\frac{1}{1} = 0$.
So one unique type usage without any ``neighbors'' to consider is totally normal and not strange.
On the other hand, given a type usage $b$ with $99$ almost similar and no other exactly similar type usages, we have $|E(b)| = 1$ and $|A(b)| = 99$.
Which results in a strangeness score of $\operatorname{S-score}(b) = 1-\frac{1}{1+99} = 0.99$.
Following intuition such a type usage is very strange and indeed, the S-score supports this.

\subsection{Which Calls are missing?}

It is not enough to only detect those type usages which are somewhat strange.
We would also like to present the developer with some candidate suggestions, what might be the method call that is missing.

The intuition for this is to look at all the almost similar type usages and the additional method call that they invoke.
Then take the frequency of each unique method call among them and take this as the suggestion likelihood.
\todo{don't like the formulation, improve!}

\todo[inline]{example!!! with a couple of tus and their methodcalls -> calculate the likelihood}

Formally, the calls we can recommend for a type usage $x$ are the calls that are present in the type usages in $A(x)$ but not in $M(x)$.
The set of these methods shall be called $R(x)$ and is defined as follows:
\begin{equation*}
    R(x) = \bigcup_{z \in A(x)} M(z) \setminus M(x)
\end{equation*}
% todo use this equation or the one in their paper (should be identical, which one is easier to follow?) + make sure about klammersetzung

%--- how to decide which is the call which is missing most likely
Now for each of these methods $m$ in $R(x)$, we can calculate their likelihood as follows:
\begin{equation*}
    \phi(m, x) = \frac{|\{z \mid z \in A(x) \land m \in M(z)\}|}{|A(x)|}
\end{equation*}

This is identical to the share of type usages which use this method among all the type usages which are almost similar to $x$.
Observe that this definition also works when $M(x)$ is empty or $x$ is \code{this}.

\todo[inline] {consider the example + example explanation (a number tus, maybe of the Button example from introduction?)}

\subsection{Caveats}
really include here or only in Evaluation section?
%--- caveats
do real software systems actually behave in this way
ie: is it ``necessary'' to use classes in the same way
probably: most likely present in GUI systems

\section{Extensions}
-> My work
theoretical explanation of the different approaches

\subsection{Modifying the Input Data}
stupid title, change it!

load type usages in different ways
    per class type usages / ignore context
    working with the inheritance hierarchy!

\subsection{Other errors}
    look for different things (wrong method call, superfluous method)

\subsection{Better Anomaly Detection}
    clustering approach (hypersphere)
    something as of now unknown from anomaly detection

    -> do I really need this section? maybe only in Implementation?
