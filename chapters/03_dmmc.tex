\chapter{Detecting Missing Method Calls}\label{ch:dmmc}

analogy: remove with waiter
irgendwo erlÃ¤utern PART 1 ist background (Foundation: Majority rule)
3.2 = mein teil


\todo[inline]{better intro\ldots}
As mapped out in Section \ref{ch:intro} bugs related to missing method calls occur in real software systems.
These bugs are often related to complicated APIs and frameworks, and we would like to detect them.
The idea is to detect patterns in correct usages which will enable us to single out the faulty ones.

%--- overview of this chapter
In this chapter we will first give a proper explanation of the method proposed by Monperrus et al. \cite{monperrus2010detecting}\cite{monperrus2013detecting} based on the majority rule.
This includes a proper qualification of the notions of type usages, as well as their equality and almost equality, which we already mentioned in the previous chapter.
We will then explain how the strangeness score, which describes the degree to which a particular type usage is different from its relevant neighbors, is calculated, before going into detail how the potentially missing calls are determined.

In the second section of this chapter, we explain some minor tweaks to the type usage notion, whose ability to detect missing method calls we explore further in Chapter \ref{ch:eval}.
\todo[inline]{more details? -> when proper contents are decided + do not mention chapter 5}

\section{Foundation: The Majority Rule}
%-> existing work
\todo[inline]{make sure that chapter intro + this section intro work well together}

The intuition behind the majority rule is that a piece of code is likely to contain a defect if there are none or very few equal instances, but a lot of slightly different instances.
It then seems likely that the code which appears a selected few times only should be adapted in a way to match the majority of slightly different instances.

-> remove?! / use with methods!
An analogy which explains the idea well goes as follows.
Imagine being the waiter preparing the tables in a restaurant.
There are 100 seats, and each of them is equipped with a plate, a knife on the right and a fork on the left.
However, of these seats only 99 have a spoon above the plate, and there is one seat $s$ which is missing the spoon.
Then it is highly likely, that this one exception to the rule ``each seat should have a plate, a knife, a fork and a spoon'' is a mistake, and you should add the spoon to the single seat $s$ where it is missing.

The remainder of this section extends this idea to object-oriented software and formalizes the different notions required to implement a system detecting such places.
In this context each piece of cutlery (knife, spoon, fork) can be imagined as a method call, i.e., we extend the concept of the majority rule to types and method calls.

\subsection{Type Usages}
\todo[inline]{make paragraphs instead of subsections?}

Generally speaking, type usages are an abstraction over the analyzed code.
They ignore the order of method calls and are only concerned with the list of method calls invoked on some object.
The critical information which is associated with a type usage is thus as follows: the type of the object, the list of methods invoked on it and the context in which the object is used.
We define the context as the name of the method in whose body the type usage appears together with the type of its parameters.
%todo I think the return type is ignored?

%--- formalized -> reread the papers for inspiration
Formalized, given some code the type usages are extracted as follows:
For each variable $x$, note its type $T(x)$ and the context $C(x)$ in which it occurs.
Additionally, save the list of methods which are invoked on $x$ within $C(x)$: $M(x) =\{ m_1, m_2, \dotsc, m_n\}$.
If there are two variables of the same type, this results in two type usages being extracted (unless they refer to the same object, more on this in Section \ref{sec:bytecode}).

\begin{figure}[h]
    \begin{subfigure}[c]{0.5\textwidth}
        \begin{lstlisting}[language=java, basicstyle=\small]
class A extends Page {
    Button b;

    Button createButton() {
        b = new Button();
        b.setText("hello");
        b.setColor(GREEN);
        ... (other code)
        Text t = new Text();
        return b;
    }
}
        \end{lstlisting}
    \end{subfigure}
    \begin{subfigure}[c]{0.5\textwidth}
        \begin{lstlisting}[basicstyle=\small]
T(b) = 'Button'
C(b) = 'Page.createButton()'
M(b) = {<init>, setText, setColor}

T(t) = 'Text'
C(t) = 'Page.createButton()'
M(t) = {<init>}
        \end{lstlisting}
    \end{subfigure}
    \caption{Example illustrating the Extraction of Type Usages (taken from \cite{monperrus2013detecting})}
    \label{fig:tu_example}
\end{figure}

As an example, consider the code in Figure \ref{fig:tu_example}.
It contains two type usages, one of type \code{Button} and another one of type \code{Text}.
The context for both is \code{createButton()}.
The methods invoked on the \code{Button} object are initialization (\code{new}), \code{setText} and \code{setColor}.
The \code{Text} object, on the other hand, is only initialized.
Given the two variables $b$ and $t$ as input, the corresponding values of $T(x)$, $C(x)$ and $M(x)$ are shown on the right hand side.

\subsection{Exact and Almost Similarity}

\todo{ explain better what a SIMILAR method is (if so mention what it is) + SAME method }

%--- what are exactly equal and almost equal
To detect type usages which are anomalous by the majority rule, we now need a notion what it means for two type usages to be exactly similar and only almost similar.
\todo{some better explanation WHY we need this / add it in section intro?}
Informally, we say that two type usages are exactly similar, iff they have the same type, the type usage appears in a similar method (i.e., the context is identical) and if their list of method calls is identical.
We call these type usages ``similar'' instead of ``equal'' because several things are indeed not the same: variable names, surrounding or interspersed code, method order and the concrete location (class) are all disregarded and might indeed differ.

The notion of almost similarity is also not far away.
We say that a type usage $y$ is almost similar to a given type usage $x$, if they share the same type and context and the list of method calls of $y$ is the same as the method calls of $x$ plus one additional call.

\begin{figure}[h]
    \centering
    \begin{subfigure}[c]{0.47\textwidth}
        \begin{lstlisting}[language=java, frame=single, basicstyle=\footnotesize]
class A extends Page {
    Button createButton() {
        Button b = new Button();
        ... (interlaced code)
        b.setText("hello");
        ... (interlaced code)
        b.setColor(BLUE);
        return b;
    }
}
        \end{lstlisting}
    \end{subfigure}
    \quad
    \begin{subfigure}[c]{0.47\textwidth}
        \begin{lstlisting}[language=java, frame=single, basicstyle=\footnotesize]
class B extends Page {
    Button createButton() {
        ... (code before)
        Button aBut = new Button();
        ... (interlaced code)
        aBut.setColor(RED);
        aBut.setText("goodbye");
        return b;
    }
}
        \end{lstlisting}
    \end{subfigure}
    \\

    \begin{subfigure}[c]{0.47\textwidth}
        \begin{lstlisting}[language=java, frame=single, basicstyle=\footnotesize, showstringspaces=false]
class C extends Page {
    Button myBut;
    Button createButton() {
        Button myBut = new Button();
        myBut.setColor(ORANGE);
        myBut.setText("Great Company!");
        myBut.setLink("https://www.cqse.eu");
        ... (code after)
        return b;
    }
}
        \end{lstlisting}
    \end{subfigure}
    \quad
    \begin{subfigure}[c]{0.47\textwidth}
        \begin{lstlisting}[language=java, frame=single, basicstyle=\footnotesize, showstringspaces=false]
class D extends Page {
    Button createButton() {
        Button tmp  = new Button();
        tmp.setLink("https://slashdot.org/");
        ... (interlaced code)
        tmp.setText("All the news");
        tmp.setColor(GREEN);
        tmp.setTooltipText("Click me!");
        return b;
    }
}
        \end{lstlisting}
    \end{subfigure}

    \caption{Examples of similar and almost similar Type Usages (also inspired by \cite{monperrus2013detecting})}
    \label{fig:sim_asim}
\end{figure}

Consider the example code snippets in Figure \ref{fig:sim_asim}.
The type usages of \code{Button} in classes \code{A} (top left) and \code{B} (top right) are exactly similar, because they not only appear in the similar method \code{createButton}, but also invoke the same methods \code{setText} and \code{setColor}.
Observe that variable names and method parameter play no role in this.
Additionally, neither the order of methods nor any additional code (which does not call a method on the \code{Button} objects) does have any influence on it.
The type usage in class \code{C} (bottom left) is almost similar to the ones in \code{A} and \code{B}, because besides the two methods \code{setText} and \code{setColor} it also invokes one additional method: \code{setLink}.
Finally, the type usage in class \code{D} (bottom right) invokes \textbf{two} additional methods in comparison to the ones in \code{A} or \code{B}, meaning that it is not almost similar to them.
However, it is in fact almost similar to the type usage in class \code{C}, since it only invokes one additional method: \code{setTooltipText}.

%--- formalized
To formalize these notions, we define two binary relationships over type usages.
The relationship for exact similarity is called $E'$ and we say that two type usages $x$ and $y$ are exactly similar if and only if:
\begin{align*}
xE'y \iff & T(x) \: = T(y) \;\: \land \\
         & C(x) \: = C(y) \;\: \land \\
         & M(x) = M(y)
\end{align*}

Given this, the set of exactly similar type usages in relation to $x$ is defined as:
\begin{equation*}
E(x) = \{y \mid xE'y \}
\end{equation*}
Observe that this relation holds true for the identity, i.e. $xE'x$ is always true and $\forall x: x \in E(x)$ (and thus $|E(x)| \geq 1$).

For almost similarity, we define the relation $A'$ which holds if two type usages are almost similar.
A type usage $y$ is almost similar to a type usage $x$ iff:
\begin{align*}
xA'y \iff & T(x) \: = T(y) \;\; \land \\
         & C(x) \: = C(y) \;\; \land \\
         & M(x) \subset M(y) \: \land \\
         & |M(y)| = |M(x)| + 1
\end{align*}

Similarly to $E(x)$ we define $A(x)$ as the set of type usages which are almost similar to $x$:
\begin{equation*}
A(x) = \{y \mid xA'y \}
\end{equation*}

\todo{ mention it is NOT symmetric!}

In contrast to $E(x)$, $A(x)$ can be empty and $|A(x)|\geq0$.

It is possible to further refine the definition of almost similarity.
Instead of looking for type usages which have the same method calls plus one additional one, it is also possible to consider at those type usages which feature the same method calls plus $k$ additional ones.
Then, in the definition of $A$ the last line changes as follows: $|M(y)| = |M(x)| + k, k\geq1$
\todo{mention ignoring the context here?!}

Note that given a codebase with $n$ type usages the sets $E(x)$ and $A(x)$ for one given type usage $x$ can be computed in linear time $O(n)$ by iterating once through all type usages and checking for similarity or almost similarity.

\subsection{The Strangeness Score}

Recall the assumption behind the majority rule: A type usage is abnormal if a small number of type usages is exactly similar, but a large number are almost similar.
Informally, this means a few places use this type in exactly the same way, but a significant majority use it in a way which is slightly different (by exactly one method call).
Assuming the majority is correct, the type usage under scrutiny is deviant and potentially erroneous.

To capture concretely how anomalous an object is, we need a measure of strangeness.
This will be the strangeness score.
It allows to order type usages by how much of an outlier they are and thus to identify the ``strangest'' type usages, which are most interesting for evaluation by a human expert.

%--- strangeness score calculation
Formally, we define the S(trangeness)-Score as:
\begin{equation*}
    \operatorname{S-score}(x) = 1 - \frac{|E(x)|}{|E(x)|+|A(x)|}
\end{equation*}

To see that this definition makes sense, consider the following extreme cases:
Given one type usage $a$ without any additional exactly similar or almost similar type usages, it will have $|E(a)| = 1$ and $|A(a)| = 0$.
Then, we can calculate the strangeness score: $\operatorname{S-score}(a) = 1-\frac{1}{1} = 0$.
So a unique type usage without any ``neighbors'' to consider is completely normal and not strange.
On the other hand, given a type usage $b$ with $99$ almost similar and no other exactly similar type usages, we have $|E(b)| = 1$ and $|A(b)| = 99$.
Which results in a strangeness score of $\operatorname{S-score}(b) = 1-\frac{1}{1+99} = 0.99$.
Following intuition, such a type usage is very strange, and indeed, the S-score supports this.

\subsection{Which Calls are missing?}

Only detecting the type usages which are outliers is not enough.
We would also like to present the developer with some candidate suggestions, what might be the method call that is missing.

The intuition for this is to look at all the almost similar type usages and the additional method call that they invoke.
Then take the frequency of each unique method call among them and take this as the suggestion likelihood.
\todo{do not like the formulation, improve!}

Formally, the calls we can recommend for a type usage $x$ are the calls that are present in the type usages in $A(x)$ but not in $M(x)$.
The set of these methods shall be called $R(x)$ and is defined as follows:
\begin{equation*}
    R(x) = \bigcup_{z \in A(x)} M(z) \setminus M(x)
\end{equation*}
% todo use this equation or the one in their paper (should be identical, which one is easier to follow?) + make sure about klammersetzung

%--- how to decide which is the call which is missing most likely
Now for each of these methods $m$ in $R(x)$, we can calculate their likelihood as follows:
\begin{equation*}
    \phi(m, x) = \frac{|\{z \mid z \in A(x) \land m \in M(z)\}|}{|A(x)|}
\end{equation*}

This is identical to the share of type usages which use this method among all the type usages which are almost similar to $x$.
Observe that this definition also works when $M(x)$ is empty or $x$ is \code{this}.

\begin{figure}[h]
    \begin{subfigure}[c]{0.45\textwidth}
        \begin{align*}
& T(x) = \mathtt{Button} \\
& M(x) = \{ \mathtt{<\!\!init\!\!>} \} \\
& A(x) = \{ a, b, c, d, e \} \\
& M(a) = \{ \mathtt{<\!\!init\!\!>},\, \mathtt{setText} \} \\
& M(b) = \{ \mathtt{<\!\!init\!\!>},\, \mathtt{setText} \} \\
& M(c) = \{ \mathtt{<\!\!init\!\!>},\, \mathtt{setText} \} \\
& M(d) = \{ \mathtt{<\!\!init\!\!>},\, \mathtt{setText} \} \\
& M(e) = \{ \mathtt{<\!\!init\!\!>},\, \mathtt{setFont} \}
        \end{align*}
    \end{subfigure}
    \begin{subfigure}[c]{0.45\textwidth}
        \begin{align*}
& R(x) = \{ \mathtt{setText},\, \mathtt{setFont} \} \\
& \phi(setText, x) = \frac{4}{5} = 0.8 \\
& \phi(setFont, x) = \frac{1}{5} = 0.2
        \end{align*}
    \end{subfigure}
    \caption{Example for computing the Likelihood of missing Calls}
    \label{fig:missing_calls}
\end{figure}
\todo[inline]{again reference source of this example!!!}

To illustrate these definitions, consider the example in Figure \ref{fig:missing_calls}.
The type usage in question is denoted with $x$, operates on a \code{Button} object and the only method that is invoked is the initialization.
There are five almost similar usages denoted as $a$, $b$, $c$, $d$ and $e$.
Four of them ($a$ through $d$) have a call to \code{setText} after the initialization.
The last one, $e$, has a call to \code{setFont} instead.
Thus, we can recommend the methods \code{setText} and \code{setFont} with a likelihood of $4/5 = 80\%$ and $1/5 = 20\%$ respectively.

\subsection{Ignoring the context}
\todo[inline]{move this section down below extensions, but state explicitly, that they DID do this, only the rest is mine?}

%--- why we use the context at all
The reason for integrating the context into the definition of similarity and almost similarity is the idea that a type might be used in different ways depending on the situation it is used in.
An example would be the class \code{FileInputStream} which is rarely opened and closed in the same method.
Monperrus et al. \cite{monperrus2013detecting} find in their evaluation that not considering the context adds a lot of noise (not relevant items in $E(x)$ and $A(x)$) and ultimately using it improves the precision of their experiments.
%-- why it might be better to exclude the context
However, one might question the general assumption behind using the context.
The idea that types are used in different ways seems reasonable, but is the name of the function that they are used in a good separator between those use cases?
Furthermore, using the context might work well for some types and some systems, but does it make sense generally?
One problem with using the context is that it drastically reduces the number of type usages which are even considered for (almost) similarity.
In smaller datasets this makes it much more likely that ``patterns'' appear, which in truth are only artefacts of randomness.

All in all, it is not clear that using the context necessarily improves the performance of the system.
\todo{how to call it?}
Because of this, next to the standard variant $\mathnormal{DMMC}$, we also define a variant called $\mathnormal{DMMC}_{\mathnormal{noContext}}$, which does not take the context into account.
It uses adapted measures for similarity and almost similarity, $E'_{\mathnormal{noContext}}$ and $A'_{\mathnormal{noContext}}$ which are defined in the same manner as $E'$ and $A'$, except that they do not require the context of the type usages to be identical.
The definitions of $E$, $A$, $\operatorname{S-score}$ and $\phi$ stay the same, besides that they now make use of the newly defined relations.

We will shed some more light on the relative performance of the different variants in Chapter \ref{ch:eval}.

\section{Extensions}

\todo[inline]{more clearly state that this here is my work?}
In the previous section we summarized the work of Monperrus et al. \cite{monperrus2010detecting}\cite{monperrus2013detecting}, in this one we will explore some possible modifications to their method.
For instance, it might be possible to leverage the majority rule not only for detecting missing method calls, but also to identify superfluous or flat out wrong method invocations.
Additionally, there are different ways of organizing the type usage data, which could yield better results.

In this section we will give the motivation and theoretical background for those modifications, in Chapter \ref{ch:eval} we will explore further if they actually outperform the original.

\subsection{Class-based merge}

\todo[inline]{basically the claass based merge is kinda the same as the inheritance relation right? (different split to dataset, either method/not methodlevel (context) or compelte class, or smth which inherits from X?)}
\todo{question another assumption behind the std variant}

%--- idea behind this
The $\mathnormal{DMMC}_{\mathnormal{noContext}}$ variant seeks to answer the question, if it makes sense to differentiate the type usages based on the method they appear in.
Following this line of thought, it is also possible to ask, if it is optimal to collect the type usages with method granularity.
Even when ignoring the context, the type usages will still be extracted on a per method basis, that is those methods invoked in one method body will belong to one type usage.
It is possible though, that grouping method calls with class granularity yields much better results.
Often the methods invoked on one object within a specific class include many if not all of the methods invoked on it in its whole lifetime.
Even if its not all of them, a class based type usage offers a much bigger window into the objects utilization and potentially this makes it easier to detect if some method is missing.

%--- informal how it's done
We will denote this variant as $\mathnormal{DMMC}_{\mathnormal{class}}$.
To obtain the class-based type usages, we extract the type usages at method level, exactly as before.
However, before calculating the strangeness score, we merge all those type usages which are of the same type and originate from the same class.
Note that this will merge them even if the original type usages came from different objects, because tracing each objects life through the whole class would be too expensive.
With these newly produced type usages we can then calculate the set of similar and almost similar type usages using $E'_{\mathnormal{noContext}}$ and $A'_{\mathnormal{noContext}}$, respectively.

%-- formalized
To formalize $\mathnormal{DMMC}_{\mathnormal{class}}$, we need the new operator $\operatorname{Cls}(x)$ which denotes the class from which a type usage was extracted.
The set of type usages with the same type and class as $x$ is defined as:
\begin{equation*}
    TC(x) = \{ x_i \mid T(x) = T(x_i) \land Cls(x) = Cls(x_i) \}
\end{equation*}
Then we can calculate the set of new type usages as follows:
\begin{align*}
    \{ x' \mid \;  & T(x') = T(x_0),\\
                & C(x') = \bigcup{C(x_i)},\\
                & M(x') = \bigcup{M(x_i)},\\
                & \mathnormal{with} \quad x_i \in TC(x_0) \}
\end{align*}
\todo{not super clean, what is $x_0$ :/, smth like rotate through all the tus until all of them have been used?}

Recall that for exact and almost similarity we will use the version which ignores the context, so $C(x')$ is not actually that important.
\todo[inline]{ mention some effects (such as much smaller dataset, blabla?) or somewhere else? }

\subsection{Investigate different Anomalies}

While a \emph{missing} method call might be the first error type that comes to mind and also potentially the most frequent one, the general technique of the majority rule can also be easily adapted to look for two different anomalies related to method calls.
First off, it is possible to simply flip around the notion of almost similarity and investigate if there exists a superfluous method call somewhere.
Additionally, one can envision a developer to simply make the \emph{wrong} call, rather than forgetting one or adding one too many.

\todo[inline]{some more? (example), just words\ldots
namely, it can investigate if there is a superfluous method call somewhere (would expect this not too work too well\ldots) -
or simple the WRONG method call, that is instead of calling method X the developer is erroneously calling method Y}

\subsubsection{Superfluous Method}

%-- informal description
The idea behind $\mathnormal{DMMC}_{\mathnormal{superfluous}}$ is basically the inverse of the method proposed by Monperrus et al..
Instead of checking if a lot of other type usages are calling an additional method and the current one is thus missing a call, here we check if a lot of other type usages are making \emph{fewer} calls and the current one is doing something extra which it should not.
%-- idea behind this
It is not intuitively clear what kind of errors this procedure will discover or indeed if there will be any.
Furthermore, it is possible that it will only find outliers which are intentional outliers, be it to handle a special case, to work around a bug or for any other reason.
Nonetheless, it seems reasonable to investigate this idea and only dismiss it if it actually does not yield any interesting results.

\todo[inline]{ maybe best rationalization: it is there, before trying it we don't actually know if its bad, could be that this is actually a type of error which has some impact}
\todo[inline]{include some example? (either for use case or for formalization?)}

%-- formalized description
Adapting the normal system to detect this type of outlier is rather simple.
We only need to adapt the definition of $A(x)$ to:
\begin{equation*}
    A_{\mathnormal{superfluous}}(x) = \{x \mid yA'x \}
\end{equation*}

Recall that the almost similar relation $A'$ is not actually symmetric and observe that in comparison to $A(x)$, here $x$ and $y$ are flipped in the application of $A'$. 
Thus, this definition of almost similarity considers all those type usages which call one method less than the input type usage to be almost similar.
With the definition of $\operatorname{S-score}$ and $\phi$ as above, the scores will now indicate which type usage is calling anomalously many methods and which method might be the one that is too much.

\subsubsection{Wrong Method}

%-- informal description + why though
Further extending the idea of the previous section and thinking consequently, developers might \emph{miss} a method call, they might \emph{add} a useless one but, of course, they could also simply choose the \emph{wrong} one.
Especially if the developer is not all too familiar with a given framework or there is some ambiguity in the method names or documentation, it is quite possible that she chooses the wrong method for a given task.
Of course, it is possible that this type of error results in noticeable bugs much faster than a missing call, but again we do not know this before investigating.
\todo{do i even wanna mention this?}

\todo[inline]{example? maybe some sort of conversion bug?}

%-- formalized
To formalize this new variant $\mathnormal{DMMC}_{\mathnormal{wrong}}$ looking for invocations of a wrong method, we again need only change the definition of almost similarity.
This time we define a new relation $A'_{\mathnormal{wrong}}$ as follows:
\begin{align*}
xA'_{\mathnormal{wrong}}y \iff & T(x) \: = T(y) \;\; \land \\
                                & C(x) \: = C(y) \;\; \land \\
                                & M(x) \: \neq M(y) \;\; \land \\
                                & |M(x)| \:  = |M(y)| \;\; \land \\
                                & \exists S . |S| = |M(x)| - 1 \land S \subset M(x) \land S \subset M(y)
\end{align*}
\todo{can I define this a bit better or not?}

For this relation to hold, again the type and the context of both type usages have to be the same.
Furthermore, it requires that all but one method of $M(x)$ and $M(y)$ are identical, that is, the sets of method calls they make differ but only by exactly one method.

\todo[inline]{anything more here?, better description?}

%\subsection{Working with the Inheritance Hierarchy}

%todo leave this out\ldots
% I guess keep this until very last (somehow doubt I'll have the time to look into this)
